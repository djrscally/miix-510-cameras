From 85c46a859defeaf488c45ec0d3a174ac4a691618 Mon Sep 17 00:00:00 2001
From: Daniel Scally <djrscally@gmail.com>
Date: Mon, 14 Sep 2020 23:36:16 +0100
Subject: [PATCH] Add bridge driver to connect ACPI defined sensors with CIO2
 infrastructure

Signed-off-by: Daniel Scally <djrscally@gmail.com>
---
 drivers/media/pci/intel/ipu3/ipu3-cio2.c |  56 ++-
 drivers/staging/media/ipu3/Kconfig       |  13 +
 drivers/staging/media/ipu3/Makefile      |   1 +
 drivers/staging/media/ipu3/cio2-bridge.c | 457 +++++++++++++++++++++++
 4 files changed, 522 insertions(+), 5 deletions(-)
 create mode 100644 drivers/staging/media/ipu3/cio2-bridge.c

diff --git a/drivers/media/pci/intel/ipu3/ipu3-cio2.c b/drivers/media/pci/intel/ipu3/ipu3-cio2.c
index 92f5eadf2c99..be452b70c426 100644
--- a/drivers/media/pci/intel/ipu3/ipu3-cio2.c
+++ b/drivers/media/pci/intel/ipu3/ipu3-cio2.c
@@ -1719,6 +1719,42 @@ static void cio2_queues_exit(struct cio2_device *cio2)
 		cio2_queue_exit(cio2, &cio2->queue[i]);
 }
 
+void cio2_sync_state(struct device *dev)
+/*
+ * The cio2-bridge module linking sensors to the CIO2 infrastructure on ACPI
+ * platforms needs to be probed after those devices are loaded. We use device
+ * links and the sync_state callback to force that module to load at the
+ * correct time.
+ */
+{
+	struct cio2_device *cio2;
+	int ret = 0;
+
+	cio2 = dev_get_drvdata(dev);
+
+	if (!cio2) {
+		dev_err(dev, "Failed to retrieve driver data\n");
+		return;
+	}
+
+	/* enable the bridge driver to connect sensors */
+	ret = request_module("cio2-bridge");
+
+	if (ret)
+		dev_err(dev, "Failed to initialise cio2-bridge\n");
+
+	/* Register notifier for subdevices we care */
+	ret = cio2_parse_firmware(cio2);
+
+	if (ret) {
+		v4l2_async_notifier_unregister(&cio2->notifier);
+		v4l2_async_notifier_cleanup(&cio2->notifier);
+		cio2_queues_exit(cio2);
+	}
+
+	return;
+}
+
 /**************** PCI interface ****************/
 
 static int cio2_pci_config_setup(struct pci_dev *dev)
@@ -1743,9 +1779,23 @@ static int cio2_pci_probe(struct pci_dev *pci_dev,
 			  const struct pci_device_id *id)
 {
 	struct cio2_device *cio2;
+	void *sensor;
 	void __iomem *const *iomap;
 	int r;
 
+	/*
+	 * We need to probe _after_ the sensors do, in order for the ACPI bridging
+	 * module to link them cleanly. If the pci_dev->device has no consumers
+	 * linked then we need to defer
+	 */
+	sensor = (struct device *)list_first_entry_or_null(&pci_dev->dev.links.consumers,
+						struct dev_links_info, consumers);
+
+	if (!sensor) {
+		dev_info(&pci_dev->dev, "defering probe\n");
+		return -EPROBE_DEFER;
+	}
+
 	cio2 = devm_kzalloc(&pci_dev->dev, sizeof(*cio2), GFP_KERNEL);
 	if (!cio2)
 		return -ENOMEM;
@@ -1820,11 +1870,6 @@ static int cio2_pci_probe(struct pci_dev *pci_dev,
 
 	v4l2_async_notifier_init(&cio2->notifier);
 
-	/* Register notifier for subdevices we care */
-	r = cio2_parse_firmware(cio2);
-	if (r)
-		goto fail_clean_notifier;
-
 	r = devm_request_irq(&pci_dev->dev, pci_dev->irq, cio2_irq,
 			     IRQF_SHARED, CIO2_NAME, cio2);
 	if (r) {
@@ -2052,6 +2097,7 @@ static struct pci_driver cio2_pci_driver = {
 	.remove = cio2_pci_remove,
 	.driver = {
 		.pm = &cio2_pm_ops,
+		.sync_state = cio2_sync_state,
 	},
 };
 
diff --git a/drivers/staging/media/ipu3/Kconfig b/drivers/staging/media/ipu3/Kconfig
index 3e9640523e50..804278bcf0a5 100644
--- a/drivers/staging/media/ipu3/Kconfig
+++ b/drivers/staging/media/ipu3/Kconfig
@@ -14,3 +14,16 @@ config VIDEO_IPU3_IMGU
 
 	  Say Y or M here if you have a Skylake/Kaby Lake SoC with a MIPI
 	  camera. The module will be called ipu3-imgu.
+
+config VIDEO_CIO2_BRIDGE
+	tristate "IPU3 CIO2 Sensor Bridge Driver"
+	depends on PCI && VIDEO_V4L2
+	depends on X86
+	help
+	  This module is a bridge driver connecting sensors (I.E. cameras)
+	  to the CIO2 infrastructure, based on information parsed from SSDB
+
+	  Say Y or M here if your platform uses IPU3 with connections that
+	  should be defined in ACPI. The module will be called cio2-bridge.
+
+	  If in doubt, say N here.
\ No newline at end of file
diff --git a/drivers/staging/media/ipu3/Makefile b/drivers/staging/media/ipu3/Makefile
index 9def80ef28f3..12dff56dbb9e 100644
--- a/drivers/staging/media/ipu3/Makefile
+++ b/drivers/staging/media/ipu3/Makefile
@@ -10,3 +10,4 @@ ipu3-imgu-objs += \
 		ipu3-css.o ipu3-v4l2.o ipu3.o
 
 obj-$(CONFIG_VIDEO_IPU3_IMGU) += ipu3-imgu.o
+obj-$(CONFIG_VIDEO_CIO2_BRIDGE) += cio2-bridge.o
\ No newline at end of file
diff --git a/drivers/staging/media/ipu3/cio2-bridge.c b/drivers/staging/media/ipu3/cio2-bridge.c
new file mode 100644
index 000000000000..268f1775f8aa
--- /dev/null
+++ b/drivers/staging/media/ipu3/cio2-bridge.c
@@ -0,0 +1,457 @@
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <media/v4l2-subdev.h>
+
+#include <linux/fwnode.h>
+#include <linux/kref.h>
+
+static void cio2_bridge_remove(void);
+static int cio2_bridge_probe(void);
+
+#define MAX_CONNECTED_DEVICES                4
+#define SWNODE_SENSOR_HID                    0
+#define SWNODE_SENSOR_PORT                   1
+#define SWNODE_SENSOR_ENDPOINT               2
+#define SWNODE_CIO2_PORT                     3
+#define SWNODE_CIO2_ENDPOINT                 4
+#define SWNODE_NULL_TERMINATOR               5
+
+#define CIO2_HID                     "INT343E"
+#define CIO2_PCI_ID                     0x9d32
+
+#define ENDPOINT_SENSOR                      0
+#define ENDPOINT_CIO2                        1
+
+#define NODE_HID(_HID)                       \
+    (const struct software_node) {           \
+        _HID,                                \
+    }
+
+#define NODE_PORT(_PORT, _HID_NODE)          \
+    (const struct software_node) {           \
+        _PORT,                               \
+        _HID_NODE,                           \
+    }
+
+#define NODE_ENDPOINT(_EP, _PORT, _PROPS)    \
+    (const struct software_node) {           \
+        _EP,                                 \
+        _PORT,                               \
+        _PROPS,                              \
+    }
+
+#define PROPERTY_ENTRY_NULL                  \
+    (const struct property_entry) { }
+
+#define SOFTWARE_NODE_NULL                   \
+    (const struct software_node) { }
+
+/*
+ * Extend this array with ACPI Hardware ID's of devices known to be
+ * working
+ */
+
+static char* supported_devices[] = {
+    "INT33BE",
+    "OVTI2680",
+    "OVTI5648",
+};
+
+/*
+ * software_node needs const char * names. Can't snprintf a const char *,
+ * so instead we need an array of them and use the port num from SSDB as
+ * an index.
+ */
+
+const char *port_names[] = {
+    "port0", "port1", "port2", "port3", "port4",
+    "port5", "port6", "port7", "port8", "port9"
+};
+
+struct software_node cio2_hid_node = { CIO2_HID, };
+
+struct sensor {
+    struct device *dev;
+    struct software_node swnodes[5];
+    struct property_entry sensor_props[6];
+    struct property_entry cio2_props[3];
+    struct fwnode_handle *fwnode;
+};
+
+struct cio2_bridge {
+    int n_sensors;
+    struct sensor sensors[MAX_CONNECTED_DEVICES];
+    struct pci_dev *cio2;
+    struct fwnode_handle *cio2_fwnode;
+};
+
+struct cio2_bridge bridge = { 0, };
+
+static const struct property_entry remote_endpoints[] = {
+    PROPERTY_ENTRY_REF("remote-endpoint", /* Sensor 0, Sensor Property */
+                        &bridge.sensors[0].swnodes[SWNODE_CIO2_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint", /* Sensor 0, CIO2 Property */
+                        &bridge.sensors[0].swnodes[SWNODE_SENSOR_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[1].swnodes[SWNODE_CIO2_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[1].swnodes[SWNODE_SENSOR_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[2].swnodes[SWNODE_CIO2_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[2].swnodes[SWNODE_SENSOR_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[3].swnodes[SWNODE_CIO2_ENDPOINT]),
+    PROPERTY_ENTRY_REF("remote-endpoint",
+                        &bridge.sensors[3].swnodes[SWNODE_SENSOR_ENDPOINT]),
+	{ }
+};
+
+/* Data representation as it is in ACPI SSDB buffer */
+struct sensor_bios_data_packed {
+    u8 version;
+    u8 sku;
+    u8 guid_csi2[16];
+    u8 devfunction;
+    u8 bus;
+    u32 dphylinkenfuses;
+    u32 clockdiv;
+    u8 link;
+    u8 lanes;
+    u32 csiparams[10];
+    u32 maxlanespeed;
+    u8 sensorcalibfileidx;
+    u8 sensorcalibfileidxInMBZ[3];
+    u8 romtype;
+    u8 vcmtype;
+    u8 platforminfo;
+    u8 platformsubinfo;
+    u8 flash;
+    u8 privacyled;
+    u8 degree;
+    u8 mipilinkdefined;
+    u32 mclkspeed;
+    u8 controllogicid;
+    u8 reserved1[3];
+    u8 mclkport;
+    u8 reserved2[13];
+} __attribute__((__packed__));
+
+/* Fields needed by ipu4 driver */
+struct sensor_bios_data {
+    struct device *dev;
+    u8 link;
+    u8 lanes;
+    u32 mclkspeed;
+    u8 vcmtype;
+    u8 flash;
+    u8 degree;
+    u8 mclkport;
+    u16 xshutdown;
+};
+
+static int read_acpi_block(struct device *dev, char *id, void *data,
+                     u32 size)
+{
+    union acpi_object *obj;
+    struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+    struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+    int status;
+    u32 buffer_length;
+
+    status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
+    if (!ACPI_SUCCESS(status))
+        return -ENODEV;
+
+    obj = (union acpi_object *)buffer.pointer;
+    if (!obj || obj->type != ACPI_TYPE_BUFFER) {
+        dev_err(dev, "Could't read acpi buffer\n");
+        status = -ENODEV;
+        goto err;
+    }
+
+    if (obj->buffer.length > size) {
+        dev_err(dev, "Given buffer is too small\n");
+        status = -ENODEV;
+        goto err;
+    }
+
+    memcpy(data, obj->buffer.pointer, min(size, obj->buffer.length));
+    buffer_length = obj->buffer.length;
+    kfree(buffer.pointer);
+
+    return buffer_length;
+err:
+    kfree(buffer.pointer);
+    return status;
+}
+
+static int get_acpi_ssdb_sensor_data(struct device *dev,
+                    struct sensor_bios_data *sensor)
+{
+    struct sensor_bios_data_packed sensor_data;
+    int ret = read_acpi_block(dev, "SSDB", &sensor_data, sizeof(sensor_data));
+    if (ret < 0) {
+        dev_err(dev, "Failed to fetch SSDB data\n");
+        return ret;
+    }
+
+    /* Xshutdown is not part of the ssdb data */
+    sensor->link = sensor_data.link;
+    sensor->lanes = sensor_data.lanes;
+    sensor->mclkport = sensor_data.mclkport;
+    sensor->flash = sensor_data.flash;
+    sensor->mclkspeed = sensor_data.mclkspeed;
+
+    return 0;
+}
+
+static int connect_supported_devices(void)
+{
+    struct acpi_device *adev;
+    struct device *dev;
+    struct sensor_bios_data ssdb;
+    struct property_entry *sensor_props;
+    struct property_entry *cio2_props;
+    struct fwnode_handle *fwnode;
+    struct software_node *nodes;
+    struct v4l2_subdev *sd;
+    u32 *data_lanes;
+    int i, j, ret;
+
+    for (i = 0; i < ARRAY_SIZE(supported_devices); i++) {
+
+        adev = acpi_dev_get_first_match_dev(supported_devices[i], NULL, -1);
+
+        if (!adev) {
+            continue;
+        }
+
+        dev = bus_find_device_by_acpi_dev(&i2c_bus_type, adev);
+
+        if (!dev) {
+            pr_info("ACPI match for %s, but it has no i2c device",
+                                supported_devices[i]);
+            continue;
+        }
+
+        if (!dev->driver_data) {
+            pr_info("ACPI match for %s, but it has no driver yet",
+                                supported_devices[i]);
+            continue;
+        } else {
+            pr_info("Found supported device %s\n", supported_devices[i]);
+        }
+
+        /* Store sensor's existing fwnode */
+        bridge.sensors[bridge.n_sensors].fwnode = fwnode_handle_get(dev->fwnode);
+
+        get_acpi_ssdb_sensor_data(dev, &ssdb);
+
+        nodes = bridge.sensors[bridge.n_sensors].swnodes;
+        sensor_props = bridge.sensors[bridge.n_sensors].sensor_props;
+        cio2_props = bridge.sensors[bridge.n_sensors].cio2_props;
+        fwnode = bridge.sensors[bridge.n_sensors].fwnode;
+            
+        /*
+        * No way to tell how many elements this array needs until 
+        * this point unfortunately, so it will have to be dynamically
+        * allocated. use devres to avoid snafu later
+        */
+        data_lanes = devm_kmalloc(dev, sizeof(u32) * (int)ssdb.lanes,
+                            GFP_KERNEL);
+
+        if (!data_lanes) {
+            dev_err(dev, "Couldn't allocate memory for data lanes array\n");
+            return -ENOMEM;
+        }
+
+        for (j = 0; j < (int)ssdb.lanes; j++) {
+            data_lanes[j] = (u32)j+1;
+        }
+
+        sensor_props[0] = PROPERTY_ENTRY_U32("clock-frequency",
+                            ssdb.mclkspeed);
+        sensor_props[1] = PROPERTY_ENTRY_U32("bus-type", 5);
+        sensor_props[2] = PROPERTY_ENTRY_U32("clock-lanes", 0);
+        sensor_props[3] = PROPERTY_ENTRY_U32_ARRAY_LEN("data-lanes",
+                            data_lanes, (int)ssdb.lanes);
+        sensor_props[4] = remote_endpoints[(bridge.n_sensors * 2) + ENDPOINT_SENSOR];
+        sensor_props[5] = PROPERTY_ENTRY_NULL;
+
+        cio2_props[0] = PROPERTY_ENTRY_U32_ARRAY_LEN("data-lanes", data_lanes,
+                            (int)ssdb.lanes);
+        cio2_props[1] = remote_endpoints[(bridge.n_sensors * 2) + ENDPOINT_CIO2];
+        cio2_props[2] = PROPERTY_ENTRY_NULL;
+
+        /* build the software nodes */
+
+        nodes[SWNODE_SENSOR_HID] = NODE_HID(supported_devices[i]);
+        nodes[SWNODE_SENSOR_PORT] = NODE_PORT(
+                                            "port0",
+                                            &nodes[SWNODE_SENSOR_HID]);
+        nodes[SWNODE_SENSOR_ENDPOINT] = NODE_ENDPOINT(
+                                            "endpoint0",
+                                            &nodes[SWNODE_SENSOR_PORT],
+                                            sensor_props);
+        nodes[SWNODE_CIO2_PORT] = NODE_PORT(
+                                            port_names[(int)ssdb.link],
+                                            &cio2_hid_node);
+        nodes[SWNODE_CIO2_ENDPOINT] = NODE_ENDPOINT(
+                                            "endpoint0",
+                                            &nodes[SWNODE_CIO2_PORT],
+                                            cio2_props);
+        nodes[SWNODE_NULL_TERMINATOR] = SOFTWARE_NODE_NULL;
+
+        ret = software_node_register_nodes(nodes);
+        if (ret) {
+            dev_err(dev, "Failed to register the software nodes for %s\n",
+                                supported_devices[i]);
+            return 0;
+        }
+
+        fwnode = software_node_fwnode(&nodes[SWNODE_SENSOR_HID]);
+        if (!fwnode) {
+            dev_err(dev, "Failed to get fwnode from software node for %s\n",
+                                supported_devices[i]);
+            return 0;
+        }
+
+        fwnode->secondary = ERR_PTR(-ENODEV);
+        dev->fwnode = fwnode;
+
+        sd = dev_get_drvdata(dev);
+        sd->fwnode = fwnode;
+
+        /* we're done */
+        bridge.sensors[bridge.n_sensors].dev = dev;
+        bridge.n_sensors++;
+
+    }
+
+    return 0;
+}
+
+static int cio2_bridge_probe(void)
+{
+    struct fwnode_handle *fwnode;
+    int ret;
+
+    pr_info("Initing cio2-bridge module\n");
+
+    /* Register the CIO2 Parent node */
+    ret = software_node_register(&cio2_hid_node);
+
+    if (ret < 0) {
+        pr_err("Failed to register the CIO2 HID node\n");
+        return -EINVAL;
+    }
+
+    /* Check for supported devices and connect them*/
+    ret = connect_supported_devices();
+
+    if (ret < 0) {
+        pr_err("cio2_bridge: Failed to connect supported devices\n");
+        goto out;
+    }
+    
+    if (bridge.n_sensors <= 0) {
+        pr_err("Deferring probe\n");
+        software_node_unregister(&cio2_hid_node);
+        return -EPROBE_DEFER;
+    }
+
+    pr_info("Found %d supported devices\n", bridge.n_sensors);
+
+    /* Find pci device and add swnode as primary */
+    bridge.cio2 = pci_get_device(PCI_VENDOR_ID_INTEL, CIO2_PCI_ID, NULL);
+    if (!bridge.cio2) {
+        pr_err("cio2-bride: Could not find the cio2 device\n");
+        goto out;
+    }
+
+    fwnode = software_node_fwnode(&cio2_hid_node);
+    if (!fwnode) {
+        pr_err("Error getting fwnode from cio2 software_node\n");
+        ret = -ENODEV;
+        goto out;
+    }
+
+    /*
+     * We store the pci_dev's existing fwnode, beccause in the event we want 
+     * to reload (I.E. rmmod and insmod) this module we need to give the device
+     * its original fwnode back to prevent problems down the line
+     */
+
+    bridge.cio2_fwnode = fwnode_handle_get(bridge.cio2->dev.fwnode);
+
+    fwnode->secondary = ERR_PTR(-ENODEV);
+    bridge.cio2->dev.fwnode = fwnode;    
+
+    //ret = device_reprobe(&bridge.cio2->dev);
+    //if (ret) {
+    //    dev_warn(&bridge.cio2->dev, "Reprobing error: %d\n", ret);
+    //    goto out;
+    //}
+
+    return 0;
+out:
+    cio2_bridge_remove();
+    return ret;
+}
+
+static int cio2_bridge_unregister_sensors(void)
+{
+    int i,j;
+    struct sensor *sensor;
+
+    for (i=0; i < bridge.n_sensors; i++) {
+        sensor = &bridge.sensors[i];
+
+        /* give the sensor its original fwnode back */
+        sensor->dev->fwnode = sensor->fwnode;
+        fwnode_handle_put(sensor->fwnode);
+        put_device(sensor->dev);
+        
+        for (j=4; j>=0; j--) {
+            software_node_unregister(&sensor->swnodes[j]);
+        }
+    }
+
+    return 0;
+}
+
+static void cio2_bridge_remove(void)
+{
+    int ret;
+
+    /* Give the pci_dev its original fwnode back */
+    if (bridge.cio2) {
+        bridge.cio2->dev.fwnode = bridge.cio2_fwnode;
+        fwnode_handle_put(bridge.cio2_fwnode);
+        pci_dev_put(bridge.cio2);
+    }
+ 
+    ret = cio2_bridge_unregister_sensors();
+
+    if (ret)
+        pr_err("An error occurred unregistering the sensors\n");
+
+    software_node_unregister(&cio2_hid_node);
+
+    return;
+}
+
+module_init(cio2_bridge_probe);
+module_exit(cio2_bridge_remove);
+
+
+MODULE_AUTHOR("Dan Scally <djrscally@gmail.com>");
+MODULE_DESCRIPTION("Bridge driver to connect sensors to CIO2 infrastructure.");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("acpi*:INT343E:*");
-- 
2.17.1

